import { Injectable, NotFoundException, ForbiddenException, BadRequestException } from '@nestjs/common';
import { CareGroupRepository } from '../../domain/repositories/care-group.repository';
import { CareGroupMemberRepository } from '../../domain/repositories/care-group-member.repository';
import { CareGroupEntity } from '../../domain/entities/care-group.entity';
import { CareGroupMemberEntity } from '../../domain/entities/care-group-member.entity';
import { MemberRole } from '@prisma/client';

export interface CreateCareGroupDto {
  name: string;
  description?: string;
  settings?: Record<string, any>;
  inviteCode?: string;
  inviteExpiration?: Date;
}

export interface UpdateCareGroupDto {
  name?: string;
  description?: string;
  type?: CareGroupType;
  isActive?: boolean;
  settings?: Record<string, any>;
  emergencyContact?: Record<string, any>;
}

export interface InviteMemberDto {
  email: string;
  role: MemberRole;
  customTitle?: string;
  canInviteMembers?: boolean;
  canManageTasks?: boolean;
  canViewHealthData?: boolean;
}

@Injectable()
export class CareGroupService {
  constructor(
    private readonly careGroupRepository: CareGroupRepository,
    private readonly memberRepository: CareGroupMemberRepository,
  ) {}

  /**
   * Create a new care group
   */
  async createCareGroup(
    userId: string,
    createDto: CreateCareGroupDto,
  ): Promise<CareGroupEntity> {
    // Create the care group entity
    const careGroupData = CareGroupEntity.create({
      name: createDto.name,
      description: createDto.description,
      type: createDto.type,
      createdBy: userId,
      settings: createDto.settings,
      emergencyContact: createDto.emergencyContact,
    });

    // Save the care group
    const careGroup = await this.careGroupRepository.create(
      new CareGroupEntity(
        '', // ID will be generated by database
        careGroupData.name,
        careGroupData.description,
        careGroupData.type,
        careGroupData.createdBy,
        careGroupData.isActive,
        careGroupData.settings,
        careGroupData.emergencyContact,
        new Date(),
        new Date(),
      )
    );

    // Add the creator as an admin member
    const memberData = CareGroupMemberEntity.create({
      groupId: careGroup.id,
      userId,
      role: MemberRole.ADMIN,
      canInviteMembers: true,
      canManageTasks: true,
      canViewHealthData: true,
    });

    await this.memberRepository.create(
      new CareGroupMemberEntity(
        '', // ID will be generated by database
        memberData.groupId,
        memberData.userId,
        memberData.role,
        memberData.customTitle,
        memberData.isActive,
        memberData.canInviteMembers,
        memberData.canManageTasks,
        memberData.canViewHealthData,
        memberData.permissions,
        new Date(),
        null,
      )
    );

    return careGroup;
  }

  /**
   * Get all care groups for a user
   */
  async getUserCareGroups(userId: string): Promise<CareGroupEntity[]> {
    return this.careGroupRepository.findByUserId(userId);
  }

  /**
   * Get a specific care group by ID
   */
  async getCareGroupById(
    groupId: string,
    userId: string,
  ): Promise<CareGroupEntity> {
    const careGroup = await this.careGroupRepository.findById(groupId);
    if (!careGroup) {
      throw new NotFoundException('Care group not found');
    }

    // Check if user has access to this group
    const hasAccess = await this.careGroupRepository.checkUserHasAccess(
      groupId,
      userId,
    );
    if (!hasAccess) {
      throw new ForbiddenException('Access denied to this care group');
    }

    return careGroup;
  }

  /**
   * Update a care group
   */
  async updateCareGroup(
    groupId: string,
    userId: string,
    updateDto: UpdateCareGroupDto,
  ): Promise<CareGroupEntity> {
    const careGroup = await this.getCareGroupById(groupId, userId);

    // Check if user is admin or creator
    const isAdmin = await this.memberRepository.checkMemberIsAdmin(
      groupId,
      userId,
    );
    const isCreator = careGroup.isCreatedBy(userId);

    if (!isAdmin && !isCreator) {
      throw new ForbiddenException(
        'Only admins or creators can update care groups',
      );
    }

    return this.careGroupRepository.update(groupId, updateDto);
  }

  /**
   * Delete a care group
   */
  async deleteCareGroup(groupId: string, userId: string): Promise<void> {
    const careGroup = await this.getCareGroupById(groupId, userId);

    // Only creator can delete the group
    if (!careGroup.isCreatedBy(userId)) {
      throw new ForbiddenException('Only the creator can delete the care group');
    }

    await this.careGroupRepository.delete(groupId);
  }

  /**
   * Get care group members
   */
  async getCareGroupMembers(
    groupId: string,
    userId: string,
  ): Promise<CareGroupMemberEntity[]> {
    // Verify user has access to the group
    await this.getCareGroupById(groupId, userId);

    return this.memberRepository.findByGroupId(groupId);
  }

  /**
   * Invite a member to the care group
   */
  async inviteMember(
    groupId: string,
    userId: string,
    inviteDto: InviteMemberDto,
  ): Promise<{ success: boolean; message: string }> {
    // Verify user has access and permission to invite
    await this.getCareGroupById(groupId, userId);

    const canInvite = await this.memberRepository.checkMemberCanInvite(
      groupId,
      userId,
    );
    if (!canInvite) {
      throw new ForbiddenException('You do not have permission to invite members');
    }

    // TODO: Implement actual invitation logic (email sending, etc.)
    // For now, return success message
    return {
      success: true,
      message: `Invitation sent to ${inviteDto.email}`,
    };
  }

  /**
   * Join a care group (for invited users)
   */
  async joinCareGroup(
    groupId: string,
    userId: string,
    invitationCode?: string,
  ): Promise<CareGroupMemberEntity> {
    const careGroup = await this.careGroupRepository.findById(groupId);
    if (!careGroup) {
      throw new NotFoundException('Care group not found');
    }

    if (!careGroup.canAcceptNewMembers()) {
      throw new BadRequestException('Care group is not accepting new members');
    }

    // Check if user is already a member
    const existingMember = await this.memberRepository.findByGroupAndUser(
      groupId,
      userId,
    );
    if (existingMember) {
      throw new BadRequestException('User is already a member of this group');
    }

    // Check group capacity
    const maxMembers = careGroup.getMaxAllowedMembers();
    const hasCapacity = await this.careGroupRepository.checkGroupCapacity(
      groupId,
      maxMembers,
    );
    if (!hasCapacity) {
      throw new BadRequestException('Care group has reached maximum capacity');
    }

    // Create new member with default role
    const memberData = CareGroupMemberEntity.create({
      groupId,
      userId,
      role: MemberRole.MEMBER,
    });

    return this.memberRepository.create(
      new CareGroupMemberEntity(
        '', // ID will be generated by database
        memberData.groupId,
        memberData.userId,
        memberData.role,
        memberData.customTitle,
        memberData.isActive,
        memberData.canInviteMembers,
        memberData.canManageTasks,
        memberData.canViewHealthData,
        memberData.permissions,
        new Date(),
        null,
      )
    );
  }

  /**
   * Update member role and permissions
   */
  async updateMember(
    groupId: string,
    memberId: string,
    userId: string,
    updates: {
      role?: MemberRole;
      customTitle?: string;
      canInviteMembers?: boolean;
      canManageTasks?: boolean;
      canViewHealthData?: boolean;
    },
  ): Promise<CareGroupMemberEntity> {
    // Verify user has admin access
    await this.getCareGroupById(groupId, userId);

    const isAdmin = await this.memberRepository.checkMemberIsAdmin(
      groupId,
      userId,
    );
    if (!isAdmin) {
      throw new ForbiddenException('Only admins can update member permissions');
    }

    const member = await this.memberRepository.findById(memberId);
    if (!member || member.groupId !== groupId) {
      throw new NotFoundException('Member not found in this care group');
    }

    return this.memberRepository.update(memberId, updates);
  }

  /**
   * Remove a member from the care group
   */
  async removeMember(
    groupId: string,
    memberId: string,
    userId: string,
  ): Promise<void> {
    // Verify user has admin access
    await this.getCareGroupById(groupId, userId);

    const isAdmin = await this.memberRepository.checkMemberIsAdmin(
      groupId,
      userId,
    );
    if (!isAdmin) {
      throw new ForbiddenException('Only admins can remove members');
    }

    const member = await this.memberRepository.findById(memberId);
    if (!member || member.groupId !== groupId) {
      throw new NotFoundException('Member not found in this care group');
    }

    // Cannot remove the last admin
    if (member.role === MemberRole.ADMIN) {
      const adminCount = await this.memberRepository.getAdminCount(groupId);
      if (adminCount <= 1) {
        throw new BadRequestException('Cannot remove the last admin from the group');
      }
    }

    await this.memberRepository.delete(memberId);
  }

  /**
   * Get care group statistics
   */
  async getCareGroupStatistics(
    groupId: string,
    userId: string,
  ): Promise<{
    memberCount: number;
    taskCount: number;
    completedTaskCount: number;
    activityCount: number;
    recipientCount: number;
  }> {
    // Verify user has access
    await this.getCareGroupById(groupId, userId);

    return this.careGroupRepository.getGroupStatistics(groupId);
  }

  /**
   * Search care groups by name
   */
  async searchCareGroups(
    userId: string,
    searchTerm: string,
  ): Promise<CareGroupEntity[]> {
    return this.careGroupRepository.searchByName(userId, searchTerm);
  }

  /**
   * Get active care groups for user
   */
  async getActiveCareGroups(userId: string): Promise<CareGroupEntity[]> {
    return this.careGroupRepository.findActiveGroups(userId);
  }
}
