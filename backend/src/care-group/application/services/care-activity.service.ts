import {
  Injectable,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { CareActivityRepository } from '../../domain/repositories/care-activity.repository';
import { CareGroupMemberRepository } from '../../domain/repositories/care-group-member.repository';
import { CareActivityEntity } from '../../domain/entities/care-activity.entity';
import { ActivityType } from '@prisma/client';

export interface CreateActivityDto {
  type: ActivityType;
  title: string;
  description?: string;
  metadata?: Record<string, any>;
}

export interface ActivityFilters {
  type?: ActivityType;
  userId?: string;
  fromDate?: Date;
  toDate?: Date;
  limit?: number;
}

@Injectable()
export class CareActivityService {
  constructor(
    private readonly activityRepository: CareActivityRepository,
    private readonly memberRepository: CareGroupMemberRepository,
  ) {}

  /**
   * Create a new activity in a care group
   */
  async createActivity(
    groupId: string,
    userId: string,
    createDto: CreateActivityDto,
  ): Promise<CareActivityEntity> {
    // Verify user has access to this group
    const member = await this.memberRepository.findByGroupAndUser(
      groupId,
      userId,
    );
    if (!member) {
      throw new ForbiddenException('User is not a member of this care group');
    }

    // Create activity data
    const activityData = {
      groupId,
      memberId: member.id,
      activityType: createDto.type,
      description: createDto.description || 'Activity created',
      data: createDto.metadata || {},
    };

    return this.activityRepository.create(activityData);
  }

  /**
   * Get activities for a care group
   */
  async getGroupActivities(
    groupId: string,
    userId: string,
    filters?: ActivityFilters,
  ): Promise<CareActivityEntity[]> {
    // Verify user has access to this group
    const member = await this.memberRepository.findByGroupAndUser(
      groupId,
      userId,
    );
    if (!member) {
      throw new ForbiddenException('User is not a member of this care group');
    }

    return this.activityRepository.findByGroupId(groupId, filters);
  }

  /**
   * Get a specific activity
   */
  async getActivity(
    activityId: string,
    groupId: string,
    userId: string,
  ): Promise<CareActivityEntity> {
    // Verify user has access to this group
    const member = await this.memberRepository.findByGroupAndUser(
      groupId,
      userId,
    );
    if (!member) {
      throw new ForbiddenException('User is not a member of this care group');
    }

    const activity = await this.activityRepository.findById(activityId);
    if (!activity || activity.groupId !== groupId) {
      throw new NotFoundException('Activity not found in this care group');
    }

    return activity;
  }

  /**
   * Get activities for a specific user across all their groups
   */
  async getUserActivities(
    userId: string,
    filters?: ActivityFilters,
  ): Promise<CareActivityEntity[]> {
    return this.activityRepository.findByUserId(userId, filters);
  }

  /**
   * Get recent activities for a care group
   */
  async getRecentActivities(
    groupId: string,
    userId: string,
    limit: number = 20,
  ): Promise<CareActivityEntity[]> {
    // Verify user has access to this group
    const member = await this.memberRepository.findByGroupAndUser(
      groupId,
      userId,
    );
    if (!member) {
      throw new ForbiddenException('User is not a member of this care group');
    }

    return this.activityRepository.findRecentByGroupId(groupId, limit);
  }

  /**
   * Log a system activity (e.g., member joined, task completed)
   */
  async logSystemActivity(
    groupId: string,
    type: ActivityType,
    title: string,
    description?: string,
    metadata?: Record<string, any>,
    userId?: string,
  ): Promise<CareActivityEntity> {
    // For system activities, we don't need to verify user membership
    // as these are generated by the system itself
    const activityData = {
      groupId,
      memberId: userId || 'system',
      activityType: type,
      description: description || 'System activity',
      data: metadata || {},
    };

    return this.activityRepository.create(activityData);
  }

  /**
   * Delete an activity (only for admins or activity creator)
   */
  async deleteActivity(
    activityId: string,
    groupId: string,
    userId: string,
  ): Promise<void> {
    const activity = await this.getActivity(activityId, groupId, userId);

    // Verify user has permission to delete this activity
    const member = await this.memberRepository.findByGroupAndUser(
      groupId,
      userId,
    );
    const isAdmin = member?.role === 'ADMIN';
    const isCreator = activity.memberId === member?.id;

    if (!isAdmin && !isCreator) {
      throw new ForbiddenException(
        'User does not have permission to delete this activity',
      );
    }

    await this.activityRepository.delete(activityId);
  }

  /**
   * Get activity statistics for a group
   */
  async getActivityStatistics(
    groupId: string,
    userId: string,
    _fromDate?: Date,
    _toDate?: Date,
  ): Promise<{
    totalActivities: number;
    taskActivities: number;
    memberActivities: number;
    recipientActivities: number;
    systemActivities: number;
    recentActivities: number;
  }> {
    // Verify user has access to this group
    const member = await this.memberRepository.findByGroupAndUser(
      groupId,
      userId,
    );
    if (!member) {
      throw new ForbiddenException('User is not a member of this care group');
    }

    return this.activityRepository.getActivityStatistics(groupId);
  }

  /**
   * Mark activities as read for a user
   */
  async markActivitiesAsRead(
    groupId: string,
    userId: string,
    activityIds: string[],
  ): Promise<void> {
    // Verify user has access to this group
    const member = await this.memberRepository.findByGroupAndUser(
      groupId,
      userId,
    );
    if (!member) {
      throw new ForbiddenException('User is not a member of this care group');
    }

    // Verify all activities belong to this group
    for (const activityId of activityIds) {
      const activity = await this.activityRepository.findById(activityId);
      if (!activity || activity.groupId !== groupId) {
        throw new NotFoundException(
          `Activity ${activityId} not found in this care group`,
        );
      }
    }

    // TODO: Implement markAsRead in repository
    // await this.activityRepository.markAsRead(activityIds, userId);
  }

  /**
   * Get unread activity count for a user in a group
   */
  async getUnreadActivityCount(
    groupId: string,
    userId: string,
  ): Promise<number> {
    // Verify user has access to this group
    const member = await this.memberRepository.findByGroupAndUser(
      groupId,
      userId,
    );
    if (!member) {
      throw new ForbiddenException('User is not a member of this care group');
    }

    // TODO: Implement getUnreadCount in repository
    return 0; // this.activityRepository.getUnreadCount(groupId, userId);
  }
}
